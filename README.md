실전 스프링 부트와 JPA 활용 (API 개발과 성능 최적화)
====================================================

1장 강좌 소개
-------------

-	1편에서는 기능개발에 초점을 맞춤

-	실무에서는 단순히 기능개발의 단계를 넘어서 기술문제를 해결할 수 있어야 함

-	JPA 극한의 성능최적화 노하우를 전수해준다고 함

-	실무 JPA 성능 문제의 90% 해결할 수 있다고 함

-	일단 필요소스 는 여기서 가져오자

	-	https://github.com/MorrisHong

-	최초 h2 생성은

	-	관리자 모드에서
	-	jdbc:h2:~/db이름

2장 API 개발 기본
-----------------

### 2.1 회원 등록 API

-	요즘에는 화면으로 템플릿엔진을 통해 만드는 곳 보다는 싱글페이지 애플리케이션으로 개발이 많이 됨

	-	API로 백단이랑 통신하는 일이 많아짐

-	API는 템플릿엔진을 사용하는 부분의 에러처리와 달리 공통 에러JSON을 반환해야함 그래서 패키지를 분리할 것

-	@RequestBody

	-	json 형태로 온 데이터를 객체로 바꿔줌

-	request 값을 엔티티로 바로 쓰면 문제가 많음

	-	엔티티가 바뀔 확률이 높은데, 이게 바뀐다고해서 API 스펙이 바뀌면 안됨.
	-	api 스펙을 위한 별도의 dto를 만들어야 한다.
	-	api를 만들 때는 항상 엔티티를 파라미터로 받지말자. 노출해서도 안된다.

	-	dto를 만들어서 api가 원하는 스펙에 맞게 제한하면 됨. 엔티티에서 제한하면 어떤 api에선 필요한 건데 안맞을 수 있음 (정석임)

	-	**api는 요청이 나가는 것과 들어오는 것 전부다 dto로 하자!**

-	참고

	-	2.3.x 부터 @Vaild 가 org.springframework.boot:spring-boot-starter-validation 로 따로 빠짐 depenencies 에 추가할 것

### 2.2 회원 수정 API & 2.3 회원 조회 API

-	dto를 통해 필요한 것만 노출하자

3장 API 개발 고급 - 준비
------------------------

### 3.1 API 개발 고급 소개

-	주로 조회 API가 문제임

	-	최적화에 대해 배운다

### 3.1 조회용 샘플 데이터 입력

-	UserA

	-	JPA1 Book
	-	JPA2 Book

-	UserB

	-	SPRING1 Book
	-	SPRING2 Book

-	OrderItem... orderItems

	-	파라미터 배열로 넘길수있음

-	@PostConstruct 안에 다 넣지 않는 이유

	-	스프링 라이프사이클 때문에 transaction 등이 제대로 동작하지 않으므로 별도의 빈으로 등록

4장 API 개발 고급 - 지연 로딩과 조회 성능 최적화
------------------------------------------------

### 4.1 간단한 주문 조회 V1: 엔티티를 직접 노출

-	주문 + 배송정보 + 회원을 조회하는 API

	-	지연 로딩 때문에 발생하는 성능 문제를 단계적으로 해결하는 것이 목표

-	order 엔 member 가 있고 member엔 order 가 있어서 무한루프에 빠짐

	-	양방향 연관관계 매핑 시 한쪾은 @jsonignore를 해야함

-	lazy 로딩 시 type definition error 가 발생할 수 있음

	-	get해서 사용하지 않으면 jpa가 member를 프록시객체로 만들어놓음 (bytebuddyinterceptor)
	-	hibernate5module 을 통해 없는거 빼고 표출할 수 는 있음 (잘 안씀)
	-	이거보다는 dto로 반환하는 것이 좋은 방법임

### 4.2 간단한 주문 조회 V2 : 엔티티를 DTO로 변환

-	dto를 변환하면서 lazy 초기화가 발생

-	ORDER -> SQL 1번 -> 결과 2개

	-	첫번째 루프 : 오더 2개 조회
	-	두번째 루프 : 오더 2개 조회

-	그렇다고 EAGER는 쿼리 예측이 안됨.

	-	사용자제 (모든 연관관계는 LAZY로 설정할 것)

### 4.3 간단한 주문 조회 V3 : 페치 조인 최적화

-	join fetch는 jpa에만 있는 문법임

	-	한방 쿼리로 데이터 가져오기

-	jpa의 90% 문제는 페치조인으로 해결 가능

### 4.4 간단한 주문 조회 V4 : JPA에서 DTO 바로 조회

-	바로 dto로 꺼내면 조금 더 성능 최적화 가능함

	-	new 명령어를 사용해서 JPQL의 결과를 DTO로 즉시 변환

	-	select 절에서 원하는 데이터를 직접 선택하므로 DB -> 애플리케이션 네트웍 용량 최적화 (실제 차이는 미비)

	-	리파지토리 재사용성이 떨어짐, API 스펙에 맞춘 코드가 리포지토리에 들어가는 단점

-	만약 dto 조회 쿼리를 생성하야할 경우에는 일반 repository와 분리해서 사용할 것!

	-	유지보수하기 좋음

-	쿼리 방식 선택 권장 순서

	-	우선 엔티티를 DTO로 변환하는 방법을 선택한다.
	-	필요하면 페치 조인으로 성능을 최적화 한다. (대부분 성능이슈 해결)
	-	그래도 안되면 DTO로 직접 조회하는 방법을 사용
	-	최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용

5장 API 개발 고급 - 컬렉션 조회 최적화
--------------------------------------

-	일대다 관계(OneToMany)를 조회하고, 최적화하는 방법을 알아보자.

### 5.1(5.2) 주문 조회 V1, V2 : 엔티티 직접 노출, 엔티티를 DTO로 변환

-	위와 동일하나 컬렉션을 대상으로 진행

-	dto 안에 엔티티가 있는 것도 안됨!

	-	완전 엔티티에 대한 의존을 끊어야함

### 5.3 주문 조회 V3 : 엔티티를 DTO로 변환 - 페치 조인 최적화

-	페치 조인으로 SQL 이 1번만 실행됨

-	distinct

	-	1대 다 조인으로 데이터베이스 row가 증가함
	-	db의 distinct 기능 뿐만아니라 jpa에서 엔티티가 같은 id 값이면 중복 제거해줌

-	1대다 fetch join 시 단점

	-	페이징이 불가능
	-	하이버네이트는 경고 로그를 남기면서 모든 데이터를 DB에서 읽어오고, 메모리에서 페이징 해버림(메모리 성능 문제 발생 위험)

-	컬렉션 페치 조인은 1개만 사용할 수 있다.

	-	컬렉션 둘 이상에 페치 조인을 사용하면 안된다. 데이터가 부정합하게 조회돌 수 있음.

### 5.4 주문 조회 V3.1 : 엔티티를 DTO로 변환 - 페이징과 한계 돌파

-	컬렉션을 페치 조인하면 페이징이 불가능

	-	컬렉션을 페치조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가함
	-	알대다에서는 일을 기준으로 페이징하는 것이 목적이지만 데이터는 다를 기준으로 row가 생성됨
	-	이 경우 하이버네이트는 경고 로그를 남기고 모든 DB데이터를 읽어서 메모리에서 페이징을 시도함(장애 발생으로 이어질 수 있음)

-	한계 돌파

	-	ToOne(OneToOne, ManyToOne) 관계를 모두 페치조인 (ToOne관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않는다.)

	-	컬렉션은 지연로딩으로 조회한다.

	-	지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size, @BatchSize 를 적용한다.

		-	hibernate.default_batch_fetch_size : 글로벌 설정
		-	@BatchSize : 개발 최적화
		-	이 옵션을 사용하면 컬렉션이나 프록시 객체를 한꺼번에 설정한 size만큼 in 쿼리로 조회한다.

-	장점

	-	쿼리 호출 수가 1+N -> 1+1 로 최적회 된다.
	-	조인보다 DB데이터 전송량이 최적화된다.

		-	Order와 OrderItem을 조인하면 Order가 OrderItem 만큼 중복해서 조회된다. 이 방법은 각각 조회하므로 전송해야할 중복데이터가 없다.

	-	페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB데이터 전송량이 감소한다.

	-	컬렉션 페치 조인은 페이징이 불가능하지만 이 방법은 페이징이 가능하다.

-	결론

	-	ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다.
	-	따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고, 나머지는 hibernate.default_batch_fetch_size로 최적화하다.
	-	사이즈는 100~1000 사이 권장
		-	데이터베이스에 따라 in절 파라미터를 1000개로 제한하기도 함
		-	DB든 애플리케이션이든 순간 부하를 어디까지 견딜 수 있는지로 결정

### 5.5 주문 조회 V4 : JPA에서 DTO 직접 조회

-	엔티티를 찾을 땐 OrderRepository 그외 (화면에 맞는) 찾을 땐 패키지 나눠서 사용 (관심사 분리 가능)

-	쿼리

	-	루티1번, 컬렉션 N번 실행
	-	ToOne 관계들을 먼저 조회하고, ToMany 관계는 각각 별도로 처리한다.
		-	ToOne관계는 조인해도 데이터 row 수가 증가하지 않는다.
		-	ToMany 관계는 조인하면 row 수가 증가된다.

### 5.6 주문 조회 V5 : JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화

-	ToOne 관계들을 먼저 조회하고, 여기서 얻은 식별자 orderId로 ToMany관계인 OrderItem을 한꺼번에 조회
-	Map을 사용해서 성능최적화

### 5.7 주문 조회 V6 : JPA에서 DTO로 직접 조회, 플랫 데이터 최적화

-	쿼리는 1번

-	단점

	-	쿼리는 한번이지만 조인으로 인해 DB에서 애플리케이션에 전달하는 데이터에 중복데이터가 추가되므로 상황에 따라 V5보다 느릴 수 있음
	-	애플리케이션에서 추가 작업이 큼
	-	페이징 불가능

### 5.8 API 개발 고급 정리

-	엔티티 조회

	-	엔티티를 조회해서 그대로 반환 : v1
	-	엔티티 조회 후 DTO로 변환 : v2
	-	페치 조인으로 쿼리 수 최적화 : v3
	-	컬렉션 피이징과 한계 돌파 : v3.1
		-	컬렉션은 페치 조인 시 페이징이 불가능
		-	ToOne 관계는 페치 조인으로 쿼리 수 최적화
		-	컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, hibernate.default_batch_fetch_size, @BatchSize 최적화

-	DTO 직접 조회

	-	JPA에서 DTO를 직접 조회 : v4
	-	컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN절을 활용해서 메모리에서 미리 조회해서 최적화 : v5
	-	플랫 데이터 최적화 - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환 : v6

-	권장 순서

	-	엔티티 조회 방식으로 우선 접근

		-	페치조인으로 쿼리 수를 최적화
		-	컬렉션 최적화
			-	페치징 필요 : hibernate.default_batch_fetch_size, @BatchSize 로 최적화
			-	페치징 X : 페치조인 사용

	-	엔티티 조회방식으로 해결이 안되면 DTO 조회 방식 사용

	-	DTO 조회 방식이 해결이 안되면 NativeSQL or 스프링 JdbcTemplate

	-	참고1

		-	엔티티 조회 방식은 페치조인이나, hibernate.default_batch_fetch_size, @BatchSize 같이 코드를 거의 수정하지 않고, 옵션만 약간 변경해서 다양한 성능 최적화를 시도할 수 있다.
		-	반면에, DTO를 직접 조회하는 방식은 성능 최적화하거나 최적화 방식을 변경할 때 많은 코드를 변경해야 한다.
		-	**대부분 페치조인으로 해결됨. DTO로 많은최적화를 바라는 것보다 캐시를 사용할 것..(캐시는 DTO로)**

	-	참고2

		-	성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 함
		-	보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고 간다.
		-	엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서, 성능을 최적화할 수 있다.
		-	반면에 DTO 조회 방시은 SQL을 직접 다루는 것과 유사하기 때문에, 둘 사이에 줄타기를 해야한다.

-	DTO 조회 방식의 선택지

	-	DTO로 조회하는 방법도 각각 장단이 있음.
	-	v4는 코드가 단순함. 특정 주문 한건만 조회하면 이 방식을 사용해도 성능이 잘나옴
	-	v5는 코드가 복잡함. 여러 주문을 함꺼번에 조회하는 경우에는 v4 대신에 이것을 최적화한 v5 방식을 사용해야함.

	-	v6는 완전히 다른 접근방식임. 쿼리 한번으로 최적화 되어서 상당히 좋아보이지만, Order 기준으로 페이징이 불가능함. 실무에서는 이정도 데이터면 수백이나 수천건 단위로 페이징 처리가 꼭 필요하므로, 이 경우 선택하기 어려운 방법. 그리고 데이터가 많으면 중복 전송이 증가해서 v5와 비교해서 성능 차이도 미비함

6장 API 개발 고급 - 실무 필수 최적화
------------------------------------

### 6 OSIV와 성능 최적화

-	Open Session In View : 하이버 네이트
-	Open EntityManager In View : JPA

-	OSIV ON

	-	spring.jpa.open-in-view : true 기본 값

	-	이 기본 값을 뿌리면서 애플리케이션 시작 시점에 warn 로그를 남김

	-	OSIV 전략은 트랜잭션 시적처럼 최초 데이터베이스 커넥션 시작 시점부터 **API 응답이 끝날 때 까지** 영속성 컨텍스트와 데이터베이스 커렉션을 유지한다. 그래서 지금까지 View Template이나 API 컨트롤러에서 지연 로딩이 가능했던 것임

	-	지연로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다. (장점 )

	-	그런데 이 전략은 너무 오랜시간 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있음 (장애 발생 가능)

-	OSIV OFF

	-	spring.jpa.open-in-view: false
	-	OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환함. (커넥션을 낭비하지 않음)
	-	OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 한다. 따라서 지금까지 작성한 많은 지연 로딩 코드를 트랜잭션 안으로 넣어야하는 단점이 있다.
	-	view template에서 지연로딩이 동작하지 않음. 결론적으로 트랜잭션이 끝나기 전에 지연로딩을 강제로 호출해 두어야 한다.

-	커맨드와 쿼리 분리

	-	실무에서 OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법이 있다. 바로 Command와 Query를 분리하는 것
	-	보통 비즈니스 로직은 특정 엔티티 몇개를 등록하거나 수정하는 것이므로 성능이 크게 문제가 되지 않음
	-	그런데 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요함.
	-	하지만 그 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 안미
	-	그래서 크고 복잡한 애플리케이션을 개발한다면, 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 충분히 의미 있음.

	-	OrderService

		-	OrderService : 핵심 비즈니스 로직
		-	OrderQueryService : 화면이나 API에 맞춘 서비스 (주로 읽기 전용 트랜잭션 사용)
		-	보통 서비스 계층에서 트랜잭션을 유지함. 두 서비스 모두 트랜잭션을 유지하면서 지연로딩을 사용할 수 있다.
